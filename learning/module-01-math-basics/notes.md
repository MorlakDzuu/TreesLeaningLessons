# Заметки: Модуль 1 - Математические основы

## Ключевые концепции

### Основы теории графов

#### Определения
- **Дерево** — связный ациклический граф
- **Корневое дерево** — дерево с выделенным корневым узлом
- **Лист** — узел без потомков
- **Внутренний узел** — узел с потомками
- **Путь** — последовательность рёбер от одного узла к другому

#### Важные понятия
- **Глубина узла** — длина пути от корня до узла (корень имеет глубину 0)
- **Высота узла** — длина самого длинного пути от узла до листа (листья имеют высоту 0)
- **Высота дерева** — максимальная глубина узла в дереве
- **Уровень** — множество узлов с одинаковой глубиной

#### Свойство: n узлов = n-1 рёбер
**Доказательство:**
- Начинаем с одного узла (корень): 0 рёбер
- Каждое новое ребро добавляет ровно один новый узел
- Следовательно, для n узлов нужно n-1 рёбер

### Анализ сложности алгоритмов

#### Асимптотическая нотация
- **O (большое O)** — верхняя граница сложности
- **Ω (омега)** — нижняя граница сложности
- **Θ (тета)** — точная граница сложности

#### Важные сложности (от быстрой к медленной)
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)
```

#### Анализ операций на деревьях
- **Вычисление высоты**: O(n) времени, O(h) памяти (h — высота)
- **Подсчёт листьев**: O(n) времени, O(h) памяти
- **Обход дерева**: O(n) времени, O(h) памяти

### Математические доказательства

#### Формула высоты полного бинарного дерева

**Лемма:** Максимальное количество узлов на уровне k равно 2^k.

**Теорема:** Для полного бинарного дерева с высотой h:
- Минимум узлов: n_min = h + 1 (вырожденное дерево)
- Максимум узлов: n_max = 2^(h+1) - 1 (полностью заполненное дерево)

**Доказательство n_max:**
Суммируем узлы по всем уровням:
```
n_max = 2^0 + 2^1 + 2^2 + ... + 2^h
      = (2^(h+1) - 1) / (2 - 1)
      = 2^(h+1) - 1
```

**Формула высоты:**
Из n ≤ 2^(h+1) - 1 получаем:
```
h ≤ log₂(n+1) - 1
```

Для полностью заполненного дерева:
```
h = ⌊log₂(n+1)⌋ - 1
```

#### Рекуррентные соотношения

**Для высоты полного дерева:**
```
T(n) = T(n/2) + 1
     = O(log n)
```

**Для обхода дерева:**
```
T(n) = T(left) + T(right) + O(1)
     = O(n)  (для сбалансированного дерева)
```

**Почему поиск в BST — O(log n)?**
- На каждом шаге отбрасываем половину узлов
- Количество шагов: log₂(n)
- Сложность: O(log n)

## Важные моменты

1. **Разница между глубиной и высотой:**
   - Глубина считается от корня вниз (корень = 0)
   - Высота считается от узла к листу (лист = 0)

2. **Нулевая высота для null узла:**
   - В реализации высоты дерева используем -1 для null (концептуально правильно)
   - В подсчёте листьев используем 0 для null (null не является листом)

3. **Высота vs количество уровней:**
   - Высота дерева = максимальная глубина
   - Количество уровней = высота + 1

4. **Формула n_max = 2^(h+1) - 1:**
   - Работает только для полностью заполненного бинарного дерева
   - Для произвольного дерева: h + 1 ≤ n ≤ 2^(h+1) - 1

## Вопросы для размышления

1. Почему в дереве всегда n узлов = n-1 рёбер?
   - Потому что каждое ребро добавляет ровно один новый узел

2. Почему поиск в BST — O(log n) в среднем?
   - В сбалансированном дереве высота ≈ log n, на каждом уровне делаем O(1) операций

3. Может ли бинарное дерево иметь больше 2^h узлов на уровне h?
   - Нет, максимум 2^h узлов на уровне h

4. Почему формула содержит log₂(n+1), а не log₂(n)?
   - Потому что для полностью заполненного дерева n = 2^(h+1) - 1
   - Следовательно, n + 1 = 2^(h+1), откуда h = log₂(n+1) - 1

## Полезные ссылки

- **VisuAlgo**: https://visualgo.net/en/binarysearchtree — интерактивная визуализация
- **USFCA Visualizations**: https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
- **MIT 6.006**: Введение в алгоритмы — лекции по деревьям
- **Кормен "Алгоритмы"**: Глава 12 — Бинарные деревья поиска

## Примеры кода

### Вычисление высоты дерева
```csharp
public int Height()
{
    if (Root == null) return -1;
    return Root.Height();
}

// В классе Node:
public int Height()
{
    if (Left == null && Right == null) return 0;
    int leftHeight = Left?.Height() ?? -1;
    int rightHeight = Right?.Height() ?? -1;
    return Math.Max(leftHeight, rightHeight) + 1;
}
```

**Анализ сложности:**
- Временная: O(n) — посещаем каждый узел один раз
- Пространственная: O(h) — глубина рекурсии = высота дерева

### Подсчёт листьев
```csharp
public int CountLeaves()
{
    if (Root == null) return 0;
    return Root.CountLeaves();
}

// В классе Node:
public int CountLeaves()
{
    if (Left == null && Right == null) return 1;
    int leftLeaves = Left?.CountLeaves() ?? 0;
    int rightLeaves = Right?.CountLeaves() ?? 0;
    return leftLeaves + rightLeaves;
}
```

**Анализ сложности:**
- Временная: O(n) — посещаем каждый узел один раз
- Пространственная: O(h) — глубина рекурсии = высота дерева

### Применение формулы высоты
```csharp
/// <summary>
/// Вычисляет минимальную высоту полностью заполненного бинарного дерева
/// для заданного количества узлов.
/// </summary>
public static int MinHeightForNodes(int nodeCount)
{
    if (nodeCount == 0) return -1;
    return (int)Math.Floor(Math.Log2(nodeCount + 1)) - 1;
}

/// <summary>
/// Вычисляет максимальное количество узлов в полном бинарном дереве
/// заданной высоты.
/// </summary>
public static int MaxNodesForHeight(int height)
{
    return (int)Math.Pow(2, height + 1) - 1;
}
```

## Выводы

1. **Понимание базовых концепций** критично для анализа сложности операций на деревьях.

2. **Формула высоты полного дерева** позволяет оценивать производительность алгоритмов:
   - Сбалансированное дерево: O(log n) операций
   - Вырожденное дерево: O(n) операций

3. **Рекурсивное мышление** — ключ к пониманию и реализации алгоритмов на деревьях:
   - Базовый случай (листья, null)
   - Рекурсивный случай (обработка потомков)
   - Комбинирование результатов

4. **Анализ сложности** помогает выбрать правильную структуру данных:
   - Когда нужен быстрый поиск → сбалансированное дерево (AVL, RB-tree)
   - Когда важна простота → обычный BST
   - Когда нужна эффективность памяти → массивное представление

5. **Практика важнее теории**, но теория помогает понять "почему", а не только "как".
